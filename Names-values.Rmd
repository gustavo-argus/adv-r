# Nomes e valores {#names-values}

```{r, include = FALSE}
source("common.R")

id <- function() {
  x <- sample(c(0:9, letters[1:6]), 3, replace = TRUE)
  paste0("0x", paste(x, collapse = ""))
}
```

## Introdução

No R, é importante entender a diferença entre um objeto e seu nome. Isso ajudará 
você a:

* Prever com mais precisão como será o desempenho e o quanto de memória o seu 
código usará.
* Escrever um código mais rápido, evitando cópias acidentais, uma das principais 
fontes de lentidão em um código.
* Entender melhor as ferramentas de programação funcional do R.

O objetivo deste capítulo é ajudá-lo a entender a diferença entre nomes e 
valores, e saber quando R copiará um objeto.

### Quiz {-}

Responda às seguintes perguntas para ver se você pode pular com segurança este 
capítulo. Você pode encontrar as respostas no final do capítulo, na Seção 
\@ref(names-values-answers).

1.  Dado o seguinte *data frame*, como faço para criar uma nova coluna 
chamada "3" que contém a soma de `1` e `2`? Você só pode usar `$`, não `[[`.
O que faz com que `1`, `2` e `3` sejam opções desafiadoras para usar como nomes 
de variáveis?

    ```{r}
    df <- data.frame(runif(3), runif(3))
    names(df) <- c(1, 2)
    ```

1.  No código a seguir, `y` ocupa quanta memória?
   
    ```{r}
    x <- runif(1e6)
    y <- list(x, x, x)
    ```

1.  No exemplo a seguir, em qual linha o objeto `a` é copiado?

    ```{r}
    a <- c(1, 5, 3, 2)
    b <- a
    b[[1]] <- 10
    ```

### Sumário {-}

* A seção \@ref(o-básico-sobre-vinculação) apresenta a diferença entre
  nomes e valores e discute como `<-` faz a vinculação, ou referência,
  entre um nome e um valor.

* A seção \@ref(copiar-ao-modificar) descreve quando o R faz uma cópia: sempre 
  que modificar um vetor, você - quase sempre - estará criando um novo vetor 
  modificado. Você aprenderá a usar `tracemem()` para descobrir quando uma 
  cópia realmente ocorre. 
  Em seguida, você explorará as implicações disso conforme elas se aplicam às 
  chamadas de função, às listas, aos *data frames* e aos vetores de caracteres.
  
* A seção \@ref(object-size) explora as implicações das duas seções anteriores
  no quanto de memória é ocupada por um objeto. Como a sua intuição sobre isso
  pode estar completamente errada - e como a função `utils::object.size()` é, 
  infelizmente, imprecisa -, você aprenderá a usar a função 
  `lobstr::obj_size()`.

* A seção \@ref(modify-in-place) descreve as duas exceções importantes à ação
  copiar-ao-modificar: em ambientes e valores com um único nome, os objetos são,
  na verdade, modificados no lugar em que se encontram.

* A seção \@ref(gc) conclui o capítulo com uma discussão sobre o coletor de 
  lixo, que libera a memória usada por objetos que não são mais referenciados 
  por um nome.

### Pré-requisitos {-}

Nós vamos usar o pacote [lobstr](https://github.com/r-lib/lobstr) para ir fundo
em como o R representa internamente seus objetos.

```{r setup}
library(lobstr)
```

### Fontes {-}

Os detalhes sobre como o R faz seu gerenciamento de memória não estão 
documentados em um único local. Muitas das informações deste capítulo foram 
obtidas a partir de de uma leitura atenta da documentação (em particular, 
`?Memory` and `?gc`), da seção [memory profiling](http://cran.r-project.org/doc/manuals/R-exts.html#Profiling-R-code-for-memory-use) 
do documento _Writing R extensions_ [@r-exts], e da seção [SEXPs](http://cran.r-project.org/doc/manuals/R-ints.html#SEXPs) do documento
_R internals_ [@r-ints]. O resto eu descobri lendo o código fonte em C, 
fazendo pequenos experimentos e fazendo perguntas no fórum R-devel. 
Quaisquer erros são inteiramente meus.

## O básico sobre Vinculação {#o-básico-sobre-vinculação}
\index{bindings|seealso {assignment}}
\index{assignment}
\indexc{obj\_addr()}

Considere este código: 

```{r bind1}
x <- c(1, 2, 3)
```

É fácil ler esse código como: "crie um objeto chamado 'x', que contém os valores 
1, 2 e 3". Infelizmente, essa é uma simplificação que levará a previsões 
imprecisas sobre o que o R está realmente fazendo nos bastidores. 
É mais correto dizer que esse código está fazendo duas coisas:

* Está criando um objeto, um vetor de valores, `c(1, 2, 3)`.
* E está vinculando esse objeto a um nome, `x`.

Em outras palavras, não é o objeto/valor que tem um nome; na 
verdade, é o nome que tem um valor.

Para esclarecer melhor essa distinção, vou desenhar diagramas como este:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-1.png")
```

O nome, `x`, é desenhado com um retângulo arredondado. Possui uma seta que 
aponta para (ou vincula, ou faz referência) ao valor, o vetor `c(1, 2, 3)`. 
A seta aponta na direção oposta à seta de vinculação: `<-` 
cria uma vinculação que se inicia no nome, no lado esquerdo, e vai para o 
objeto, no lado direito.

Dessa forma, você pode pensar em um nome como uma referência a um valor. 
Por exemplo, se você executar o código a seguir, você não obterá outra cópia do 
valor `c(1, 2, 3)`. Você terá outra vinculação ao objeto já existente:

```{r bind2, dependson = "bind1"}
y <- x
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-2.png")
```

Você deve ter notado que o valor `c(1, 2, 3)` tem um rótulo: `0x74b`. 
Embora o vetor não tenha um nome, ocasionalmente precisarei me referir a um 
objeto independente de suas vinculações. Para tornar isso possível, vou rotular 
valores com um identificador exclusivo. Esses identificadores têm uma forma 
especial que se parece com o "endereço" do objeto na memória, ou seja, o local 
na memória em que o objeto está armazenado. Mas como os endereços de memória 
reais mudam toda vez que o código é executado, usamos esses identificadores.

Você pode acessar o identificador de um objeto com `lobstr::obj_addr()`. 
Isso permite que você veja que `x` e` y` apontam para o mesmo identificador:

```{r bind3, dependson = "bind2"}
obj_addr(x)
obj_addr(y)
```

Esses identificadores são longos e mudam toda vez que você reinicia o R.

Pode levar algum tempo para entender a diferença entre nomes e valores, 
mas entender isso é realmente útil na programação funcional, em que as funções
podem ter nomes diferentes em contextos diferentes.

### Nomes não-sintáticos {#non-syntactic}
\index{reserved names} 
\index{'@\texttt{`}} 
\index{non-syntactic names}

R possui regras estritas sobre o que constitui um nome válido.
Um nome __sintático__ deve possuir apenas letras[^letras], dígitos, `.` e `_`, 
mas não pode começar com `_` or um dígito. 
Além disso, você não pode usar nenhuma das __palavras reservadas__ como
`TRUE`, `NULL`, `if`, e `function` (veja a lista completa em `?Reserved` - 
em inglês). 
Um nome que não segue essas regras é um nome __não-sintático__; 
se você tentar escrever um nome assim, receberá um erro:

```{r, eval = FALSE}
_abc <- 1
#> Error: unexpected input in "_"
# (Tradução: Erro: entrada inesperada em "_")

if <- 10
#> Error: unexpected assignment in "if <-"
# (Tradução: Erro: atribuição inesperada em "if <-")
```

[^letras]: Surpreendentemente, a definicao exata do que constitui uma letra é 
determinada pelo local atual. 
Isso significa que a sintaxe do código R pode ser realmente diferente de um 
computador para outro, e que é possível que um arquivo funcione em um 
computador, mas nem sequer rode em outro! 
Evite esse problema usando os caracteres ASCII (ou seja, A-Z), o máximo 
possível.

É possível sobrepor essas regras e usar qualquer nome, isto é, qualquer 
sequência de caracteres. Basta escrevê-lo entre aspas invertidas:

```{r}
`_abc` <- 1
`_abc`

`if` <- 10
`if`
```
Embora seja improvável que você crie nomes malucos de forma deliberada, 
você precisa entender como esses nomes malucos funcionam, pois irá lidar com 
eles em algum momento (mais comumente, quando importar dados que foram criados 
fora do R).

::: sidebar
Você também _pode_ criar vinculações não-sintáticas usando aspas simples ou 
duplas (por exemplo, `"_abc" <- 1`) em vez de aspas invertidas. Mas, não deve,
pois precisará usar uma sintaxe diferente para recuperar os valores. 
A capacidade de usar seqüências de caracteres no lado esquerdo da seta de 
vinculação é um artefato histórico que vem da época em que o R não aceitava
aspas invertidas.
:::

### Exercícios

1.  Explique a relação entre `a`, `b`, `c` e `d` no código a seguir:

    ```{r}
    a <- 1:10
    b <- a
    c <- b
    d <- 1:10
    ```

1.  O código a seguir acessa a função *mean* (que retorna a média dos valores - 
    nota do tradutor) de várias maneiras. 
    Será que todas essas maneiras apontam para o mesmo identificador desse 
    objeto de tipo função? Verifique isso com `lobstr::obj_addr()`.

    ```{r, eval = FALSE}
    mean
    base::mean
    get("mean")
    evalq(mean)
    match.fun("mean")
    ```
    
1.  De forma padrão, as funções básicas do R para importação de dados, como 
    `read.csv()`, convertem automaticamente nomes não-sintáticos em nomes 
    sintáticos. Por que isso pode ser problemático? Que opção permite evitar 
    esse comportamento?
    
1.  Quais regras a função `make.names()` usa para converter nomes não-sintáticos 
    em nomes sintáticos?

1.  Eu, levemente, simplifiquei as regras que governam os nomes sintáticos. 
    Por que `.123e1` não é um nome sintático? Leia `?make.names` para mais 
    detalhes.

## Copiar-ao-modificar
\index{copiar-ao-modificar}

Considere o seguinte código. Ele vincula `x` e` y` ao mesmo valor subjacente e 
modifica `y`[^colchetes].

[^colchetes]: Você pode se surpreender ao ver `[[` sendo usado para filtrar
um vetor numérico. Voltaremos a isso na Seção \@ref(subset-single), mas, 
resumidamente, acho que você deve sempre usar `[[` quando estiver obtendo ou 
configurando um único elemento.

```{r}
x <- c(1, 2, 3)
y <- x

y[[3]] <- 4
x
```

Modificar `y` claramente não modificou `x`. Então, o que aconteceu com a 
vinculação compartilhada? Enquanto o valor associado a `y` mudou, o objeto 
original não. No lugar disso, R criou um novo objeto, `0xcd2`, uma cópia de 
`0x74b` com um valor alterado e depois revinculou `y` à esse objeto.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-3.png")
```

Esse comportamento é chamado __copiar-ao-modificar__. Entender isso melhorará 
radicalmente sua intuição sobre o desempenho de um código em R.
Uma maneira relacionada de descrever esse comportamento é dizer que os objetos 
do R são invariáveis ou __imutáveis__.
No entanto, geralmente evitarei esse termo, porque há algumas exceções 
importantes à ação de copiar-ao-modificar que você aprenderá na 
Seção \@ref(modify-in-place).

Ao explorar, de maneira interativa, o comportamento de copiar-ao-modificar, 
esteja ciente de que você obterá resultados diferentes dentro do RStudio. 
Isso ocorre porque o painel desse ambiente deve fazer uma referência a cada 
objeto para exibir informações sobre ele. 
Isso distorce sua exploração interativa, mas não afeta o código dentro das 
funções e, portanto, não afeta o desempenho durante a análise de dados. 
Para experimentação, recomendo rodar o R diretamente do terminal ou usar o 
RMarkdown (como este livro).

### `tracemem()`
\indexc{tracemem()}

Você pode ver quando um objeto é copiado com a ajuda de `base::tracemem()`. 
Depois de chamar essa função juntamente com um objeto, você obterá o endereço 
atual do objeto:

```{r trace1, eval = FALSE}
x <- c(1, 2, 3)
cat(tracemem(x), "\n")
#> <0x7f80c0e0ffc8> 
```

A partir de então, sempre que esse objeto for copiado, `tracemem()` imprimirá 
uma mensagem informando qual objeto foi copiado, seu novo endereço e a 
sequência de chamadas que levaram à cópia:

```{r trace2, dependson = "trace1", eval = FALSE}
y <- x
y[[3]] <- 4L
#> tracemem[0x7f80c0e0ffc8 -> 0x7f80c4427f40]: 
```

Se você modificar `y` novamente, ele não será copiado. Isso ocorre porque o 
novo objeto agora tem apenas um único nome vinculado a ele, então o R aplica 
o mecanismo de otimização modificar-no-local (*modify-in-place*). 
Voltaremos a isso na Seção \@ref(modify-in-place).

```{r trace3, dependson = "trace2"}
y[[3]] <- 5L

untracemem(x)
```

`untracemem()` é o oposto de `tracemem()`; desativa o rastreamento.

### Chamadas de função

As mesmas regras de cópia se aplicam para as chamadas de função. Veja o seguinte 
código:

```{r}
f <- function(a) {
  a
}

x <- c(1, 2, 3)
cat(tracemem(x), "\n")

z <- f(x)
# nada foi copiado aqui!

untracemem(x)
```

Enquanto `f()` roda, o `a` dentro da função aponta para o mesmo valor que `x` aponta fora da função:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-f1.png")
```

Você aprenderá mas sobre as convenções usadas neste diagrama na Seção
 \@ref(execution-environments). Em resumo: a função `f()` é representada pelo objeto em amarelo à direita. Ela possui um argumento formal,`a`, que se transforma em uma vinculação (indicada pela linha preta pontilhada) no ambiente de execução (o quadrado cinza) quando se roda a função.
 
Uma vez que `f()` termina de rodar, `x` e `z` apontam para o mesmo objeto. `0x74b` não é copiado porque nunca foi modificado. Se `f()` de fato modificasse `x`, o R iria criar uma nova cópia e, então, `z` iria se vincular a esse objeto.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-f2.png")
```

### Lists {#list-references}
\indexc{ref()}
\index{lists}

It's not just names (i.e. variables) that point to values; elements of lists do too. Consider this list, which is superficially very similar to the numeric vector above:

```{r list1}
l1 <- list(1, 2, 3)
```

This list is more complex because instead of storing the values itself, it stores references to them:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/list.png")
```

This is particularly important when we modify a list:

```{r list2, dependson = "list1"}
l2 <- l1
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/l-modify-1.png")
```

```{r list3, dependson = "list2"}
l2[[3]] <- 4
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/l-modify-2.png")
```

Like vectors, lists use copy-on-modify behaviour; the original list is left unchanged, and R creates a modified copy. This, however, is a __shallow__ copy: the list object and its bindings are copied, but the values pointed to by the bindings are not. The opposite of a shallow copy is a deep copy where the contents of every reference are copied. Prior to R 3.1.0, copies were always deep copies.

To see values that are shared across lists, use `lobstr::ref()`. `ref()` prints the memory address of each object, along with a local ID so that you can easily cross-reference shared components.

```{r list4, dependson = "list3"}
ref(l1, l2)
```

### Data frames {#df-modify}

Data frames are lists of vectors, so copy-on-modify has important consequences when you modify a data frame. Take this data frame as an example:

```{r}
d1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/dataframe.png")
```

If you modify a column, only _that_ column needs to be modified; the others will still point to their original references:

```{r}
d2 <- d1
d2[, 2] <- d2[, 2] * 2
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/d-modify-c.png")
```

However, if you modify a row, every column is modified, which means every column must be copied:

```{r}
d3 <- d1
d3[1, ] <- d3[1, ] * 3
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/d-modify-r.png")
```

### Character vectors
\index{string pool}

The final place that R uses references is with character vectors[^character-vector]. I usually draw character vectors like this:

[^character-vector]: Confusingly, a character vector is a vector of strings, not individual characters. 

```{r}
x <- c("a", "a", "abc", "d")
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/character.png")
```

But this is a polite fiction. R actually uses a __global string pool__ where each element of a character vector is a pointer to a unique string in the pool:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/character-2.png")
```

You can request that `ref()` show these references by setting the `character` argument to `TRUE`:

```{r}
ref(x, character = TRUE)
```

This has a profound impact on the amount of memory a character vector uses but is otherwise generally unimportant, so elsewhere in the book I'll draw character vectors as if the strings lived inside a vector.

### Exercises

1.  Why is `tracemem(1:10)` not useful?

1.  Explain why `tracemem()` shows two copies when you run this code.
    Hint: carefully look at the difference between this code and the code 
    shown earlier in the section.
     
    ```{r, results = FALSE}
    x <- c(1L, 2L, 3L)
    tracemem(x)
    
    x[[3]] <- 4
    ```

1.  Sketch out the relationship between the following objects:

    ```{r}
    a <- 1:10
    b <- list(a, a)
    c <- list(b, a, 1:10)
    ```

1.  What happens when you run this code?

    ```{r}
    x <- list(1:10)
    x[[2]] <- x
    ```
    
    Draw a picture.

## Object size
\indexc{object.size} 
\indexc{obj\_size()}
\indexc{ALTREP}
\index{memory usage}

You can find out how much memory an object takes with `lobstr::obj_size()`[^object.size]:

[^object.size]: Beware of the `utils::object.size()` function. It does not correctly account for shared references and will return sizes that are too large.

```{r}
obj_size(letters)
obj_size(ggplot2::diamonds)
```

Since the elements of lists are references to values, the size of a list might be much smaller than you expect:

```{r}
x <- runif(1e6)
obj_size(x)

y <- list(x, x, x)
obj_size(y)
```

`y` is only 80 bytes[^32bit] bigger than `x`. That's the size of an empty list with three elements:

```{r}
obj_size(list(NULL, NULL, NULL))
```

[^32bit]: If you're running 32-bit R, you'll see slightly different sizes.

Similarly, because R uses a global string pool character vectors take up less memory than you might expect: repeating a string 100 times does not make it take up 100 times as much memory.

```{r}
banana <- "bananas bananas bananas"
obj_size(banana)
obj_size(rep(banana, 100))
```

References also make it challenging to think about the size of individual objects. `obj_size(x) + obj_size(y)` will only equal `obj_size(x, y)` if there are no shared values. Here, the combined size of `x` and `y` is the same as the size of `y`:

```{r}
obj_size(x, y)
```

Finally, R 3.5.0 and later versions have a feature that might lead to surprises: ALTREP, short for __alternative representation__. This allows R to represent certain types of vectors very compactly. The place you are most likely to see this is with `:` because instead of storing every single number in the sequence, R just stores the first and last number. This means that every sequence, no matter how large, is the same size:

```{r}
obj_size(1:3)
obj_size(1:1e3)
obj_size(1:1e6)
obj_size(1:1e9)
```

### Exercises

1.  In the following example, why are `object.size(y)` and `obj_size(y)`
    so radically different? Consult the documentation of `object.size()`.

    ```{r}
    y <- rep(list(runif(1e4)), 100)
    
    object.size(y)
    obj_size(y)
    ```

1.  Take the following list. Why is its size somewhat misleading?

    ```{r}
    funs <- list(mean, sd, var)
    obj_size(funs)
    ```

1.  Predict the output of the following code:

    ```{r, results = FALSE}
    a <- runif(1e6)
    obj_size(a)
    
    b <- list(a, a)
    obj_size(b)
    obj_size(a, b)
    
    b[[1]][[1]] <- 10
    obj_size(b)
    obj_size(a, b)
    
    b[[2]][[1]] <- 10
    obj_size(b)
    obj_size(a, b)
    ```

## Modify-in-place
\index{modify-in-place}

As we've seen above, modifying an R object usually creates a copy. There are two exceptions:

* Objects with a single binding get a special performance optimisation.

* Environments, a special type of object, are always modified in place.

### Objects with a single binding {#single-binding}
\index{loops!avoiding copies in}

If an object has a single name bound to it, R will modify it in place:

```{r}
v <- c(1, 2, 3)
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/v-inplace-1.png")
```

```{r}
v[[3]] <- 4
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/v-inplace-2.png")
```

(Note the object IDs here: `v` continues to bind to the same object, `0x207`.)

Two complications make predicting exactly when R applies this optimisation challenging:

* When it comes to bindings, R can currently[^refcnt] only count 0, 1, 
  or many. That means that if an object has two bindings, and one goes away,
  the reference count does not go back to 1: one less than many is 
  still many. In turn, this means that R will make copies when it sometimes
  doesn't need to.
  
* Whenever you call the vast majority of functions, it makes a reference to the 
  object. The only exception are specially written "primitive" C functions. 
  These can only be written by R-core and occur mostly in the base package.

[^refcnt]: By the time you read this, this may have changed, as plans are afoot to improve reference counting: https://developer.r-project.org/Refcnt.html

Together, these two complications make it hard to predict whether or not a copy will occur. Instead, it's better to determine it empirically with `tracemem()`.

\index{loops!performance}
\index{for loops|see {loops}}
Let's explore the subtleties with a case study using for loops. For loops have a reputation for being slow in R, but often that slowness is caused by every iteration of the loop creating a copy. Consider the following code. It subtracts the median from each column of a large data frame: 

```{r, cache = TRUE}
x <- data.frame(matrix(runif(5 * 1e4), ncol = 5))
medians <- vapply(x, median, numeric(1))

for (i in seq_along(medians)) {
  x[[i]] <- x[[i]] - medians[[i]]
}
```

This loop is surprisingly slow because each iteration of the loop copies the data frame. You can see this by using `tracemem()`:

```{r, eval = FALSE}
cat(tracemem(x), "\n")
#> <0x7f80c429e020> 

for (i in 1:5) {
  x[[i]] <- x[[i]] - medians[[i]]
}
#> tracemem[0x7f80c429e020 -> 0x7f80c0c144d8]: 
#> tracemem[0x7f80c0c144d8 -> 0x7f80c0c14540]: [[<-.data.frame [[<- 
#> tracemem[0x7f80c0c14540 -> 0x7f80c0c145a8]: [[<-.data.frame [[<- 
#> tracemem[0x7f80c0c145a8 -> 0x7f80c0c14610]: 
#> tracemem[0x7f80c0c14610 -> 0x7f80c0c14678]: [[<-.data.frame [[<- 
#> tracemem[0x7f80c0c14678 -> 0x7f80c0c146e0]: [[<-.data.frame [[<- 
#> tracemem[0x7f80c0c146e0 -> 0x7f80c0c14748]: 
#> tracemem[0x7f80c0c14748 -> 0x7f80c0c147b0]: [[<-.data.frame [[<- 
#> tracemem[0x7f80c0c147b0 -> 0x7f80c0c14818]: [[<-.data.frame [[<- 
#> tracemem[0x7f80c0c14818 -> 0x7f80c0c14880]: 
#> tracemem[0x7f80c0c14880 -> 0x7f80c0c148e8]: [[<-.data.frame [[<- 
#> tracemem[0x7f80c0c148e8 -> 0x7f80c0c14950]: [[<-.data.frame [[<- 
#> tracemem[0x7f80c0c14950 -> 0x7f80c0c149b8]: 
#> tracemem[0x7f80c0c149b8 -> 0x7f80c0c14a20]: [[<-.data.frame [[<- 
#> tracemem[0x7f80c0c14a20 -> 0x7f80c0c14a88]: [[<-.data.frame [[<- 

untracemem(x)
```

In fact, each iteration copies the data frame not once, not twice, but three times! Two copies are made by `[[.data.frame`, and a further copy[^shallow-copy] is made because `[[.data.frame` is a regular function that increments the reference count of `x`. 

[^shallow-copy]: These copies are shallow: they only copy the reference to each individual column, not the contents of the columns. This means the performance isn't terrible, but it's obviously not as good as it could be.

We can reduce the number of copies by using a list instead of a data frame. Modifying a list uses internal C code, so the references are not incremented and only a single copy is made:

```{r, eval = FALSE}
y <- as.list(x)
cat(tracemem(y), "\n")
#> <0x7f80c5c3de20>
  
for (i in 1:5) {
  y[[i]] <- y[[i]] - medians[[i]]
}
#> tracemem[0x7f80c5c3de20 -> 0x7f80c48de210]: 
```

While it's not hard to determine when a copy is made, it is hard to prevent it. If you find yourself resorting to exotic tricks to avoid copies, it may be time to rewrite your function in C++, as described in Chapter \@ref(rcpp).

### Environments {#env-modify}
\index{reference semantics}
\index{environments}

You'll learn more about environments in Chapter \@ref(environments), but it's important to mention them here because their behaviour is different from that of other objects: environments are always modified in place. This property is sometimes described as __reference semantics__ because when you modify an environment all existing bindings to that environment continue to have the same reference.

Take this environment, which we bind to `e1` and `e2`:

```{r}
e1 <- rlang::env(a = 1, b = 2, c = 3)
e2 <- e1
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/e-modify-1.png")
```

If we change a binding, the environment is modified in place:

```{r}
e1$c <- 4
e2$c
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/e-modify-2.png")
```

This basic idea can be used to create functions that "remember" their previous state. See Section \@ref(stateful-funs) for more details. This property is also used to implement the R6 object-oriented programming system, the topic of Chapter \@ref(r6).

One consequence of this is that environments can contain themselves:

```{r}
e <- rlang::env()
e$self <- e

ref(e)
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/e-self.png")
```

This is a unique property of environments!

### Exercises

1.  Explain why the following code doesn't create a circular list.

    ```{r}
    x <- list()
    x[[1]] <- x
    ```

1.  Wrap the two methods for subtracting medians into two functions, then
    use the 'bench' package [@bench] to carefully compare their speeds. How does
    performance change as the number of columns increase?

1.  What happens if you attempt to use `tracemem()` on an environment?

## Unbinding and the garbage collector {#gc}
\index{garbage collector} 
\index{unbinding}
\indexc{rm()}

Consider this code:

```{r}
x <- 1:3
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/unbinding-1.png")
```

```{r}
x <- 2:4
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/unbinding-2.png")
```

```{r}
rm(x)
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/unbinding-3.png")
```

We created two objects, but by the time the code finishes, neither object is bound to a name. How do these objects get deleted? That's the job of the __garbage collector__, or GC for short. The GC frees up memory by deleting R objects that are no longer used, and by requesting more memory from the operating system if needed. 

R uses a __tracing__ GC. This means it traces every object that's reachable from the global[^callstack] environment, and all objects that are, in turn, reachable from those objects (i.e. the references in lists and environments are searched recursively). The garbage collector does not use the modify-in-place reference count described above. While these two ideas are closely related, the internal data structures are optimised for different use cases.

[^callstack]: And every environment in the current call stack.

The garbage collector (GC) runs automatically whenever R needs more memory to create a new object. Looking from the outside, it's basically impossible to predict when the GC will run. In fact, you shouldn't even try. If you want to find out when the GC runs, call `gcinfo(TRUE)` and GC will print a message to the console every time it runs.

\index{garbage collector!gc@\texttt{gc()}}
You can force garbage collection by calling `gc()`. But despite what you might have read elsewhere, there's never any _need_ to call `gc()` yourself. The only reasons you might _want_ to call `gc()` is to ask R to return memory to your operating system so other programs can use it, or for the side-effect that tells you how much memory is currently being used:   

```{r}
gc() 
```

`lobstr::mem_used()` is a wrapper around `gc()` that prints the total number of bytes used:

```{r}
mem_used()
```

This number won't agree with the amount of memory reported by your operating system. There are three reasons:

1. It includes objects created by R but not by the R interpreter.

1. Both R and the operating system are lazy: they won't reclaim memory 
   until it's actually needed. R might be holding on to memory because 
   the OS hasn't yet asked for it back.

1. R counts the memory occupied by objects but there may be empty gaps due to 
   deleted objects. This problem is known as memory fragmentation.

## Quiz answers {#names-values-answers}

1.  You must quote non-syntactic names with backticks: `` ` ``: for example,
    the variables `1`, `2`, and `3`.

    ```{r}
    df <- data.frame(runif(3), runif(3))
    names(df) <- c(1, 2)
    
    df$`3` <- df$`1` + df$`2`
    ```

1.  It occupies about 8 MB.
   
    ```{r}
    x <- runif(1e6)
    y <- list(x, x, x)
    obj_size(y)
    ```

1.  `a` is copied when `b` is modified, `b[[1]] <- 10`.
